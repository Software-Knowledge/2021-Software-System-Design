Lec2-Quality Attributes
---

# 1. 软件架构
1. 软件架构是结构和系统结构，包含了软件元素、这些组件的外部可视化属性以及他们之间的关系。
2. 单独的盒式模型不是架构，但是是一个开始的点
3. 架构包含了组件的行为

## 1.1. 架构扮演的角色
1. 架构是代表决定**如何实现需求**的决策的**第一批人工制品**。作为早期设计决策的体现，架构代表了那些最难更改的设计决策，因此值得**最仔细的考虑**。
2. 架构是成功完成产品线工程，与独立开发每个系统相比，以较少的工作量，成本和风险来有序地开发一系列相似系统的关键要素。
3. 当有人开始在系统上工作时，架构通常是首先要检查的设计工件。
4. 软件架构为**维护和修改**决策提供了参考**框架**。

## 1.2. 为什么软件架构是重要的
1. 软件架构提供了**沟通的工具**
   1. 这是一个可以确定和谈判利益冲突的参考框架
      1. 和用户**讨论需求**
      2. 保证客户获取到过程和成本的信息
      3. 实现决策和分配的管理
2. 软件架构表现了**最早期的决策集合**
   1. 约束着实现和开发者
      1. 实现必须要**符合架构**
      2. **资源分配的决策**约束着单独模块的实现
3. 表现了早期的设计决策
   1. 软件架构体现为了开发和维护工作的组织结构
      1. 划分为团队
      2. 预算，计划单位
      3. 基础的工作拆分架构
      4. 文档的组织
      5. CM库的组织
      6. 集成的基础
      7. 测试计划、测试的基础
      8. 运维的基础
4. 架构促进/阻碍**质量属性的实现**，比如灵活性、安全性、易用性
5. 架构会影响质量，但由于涉及许多其他因素，因此可能**无法保证**质量。
6. 架构引发有关**潜在变更**的讨论(系统的80％的工作是**部署后**的工作)
7. 架构将**更改**分为三种类型
   1. 本地：信号分量修改
   2. 非本地：几个组件修改。
   3. 架构：修改系统的基本结构，通信和协调机制
8. 架构是一种**可转移**和**可重用**的抽象：一对多映射(一种架构，许多系统)
9. 架构是**产品通用性**的基础。 整个产品线共享一个架构
10. 可以通过体系结构集成独立开发的组件来开发系统(基于omponent的软件工程-CBSE)

## 1.3. 软件架构过程
![](img/lec2/1.png)

### 1.3.1. 移动手机系统架构
![](img/lec2/2.png)

### 1.3.2. 洗衣机架构
![](img/lec2/3.png)

## 1.4. 讨论
1. 科学和工程有什么不同？
2. 软件和硬件有什么不同？
3. 架构和设计有什么不同?
4. 架构和结构有什么不同？
5. 为什么要在架构中使用抽象？

# 2. 需求
![](img/lec2/4.png)

## 2.1. 功能性需求
1. 功能性需求定义了系统必须做什么并且强调了系统如何提供价值给涉众
2. 功能性需求意味着系统的行为
3. 功能是系统完成其预期工作的能力，例如，使学生能够在线注册。
4. 通过使用许多可能的结构可以实现功能。
5. 功能在很大程度上与结构无关，因为它可以作为单个整体系统存在而没有任何内部结构。

## 2.2. 质量性需求
1. 质量要求是系统应在其功能要求之上提供的整个系统的合乎需要的特性(又称质量属性)
2. 质量要求是功能要求或整个产品的资格。软件体系结构限制了分配
3. 如果质量属性很重要，则将功能(映射)到各种结构上。

### 2.2.1. 非功能性需求
1. **非功能**要求或**体系结构**要求是用于**质量属性**的替代术语。
2. 无法正确使用功能，然后尝试适应非功能性要求(**不具备翻新质量**)。
3. 在任何设计决策中都必须考虑非功能性要求。
5. 非功能性需求分为两大类：
   1. 在执行过程中**可观察**(**外部**)：系统满足其行为要求的程度如何？ 例如性能，安全性，可用性，可用性等。
   2. 执行期间**不可观察**(**内部**)：系统的维护，集成或测试有多容易？ 例如，可修改性，可移植性，可重用性，可测试性等。

### 2.2.2. 质量属性
1. **开发完成后**，质量**不能**添加到软件密集型系统中。
2. 在**软件开发的所有阶段**都需要解决质量问题。
3. 业务目标确定系统必须具备的质量。
4. 质量属性是**系统功能的基础**，而功能是系统功能，服务和行为的基本说明。
5. 功能通常在开发计划中占据**重要位置**。
6. 但是，系统通常是**重设计**的，因为它们**缺乏所需的质量级别**，即难以维护，移植或扩展。
7. 软件体系结构限制了各种质量属性的实现，例如性能，安全性，可用性等。
8. 这就是为什么软件体系结构被认为是解决质量问题的最合适的层次。
9. 质量属性不完全取决于**设计**，也不取决于**实现或部署**。

### 2.2.3. 确定质量属性
1. 要在架构级别对其进行**评估**，必须对质量属性进行**精确定义**。
2. 质量属性**方案**用于定义所需的质量属性。
3. 场景是具有一定结构的简单句子。场景的两个主要类别是：
   1. **通用方案**是与**系统无关**的方案，用于指导质量属性要求的规范。
   2. **具体方案**是系统**特定**方案，用于指导特定系统的质量属性要求的规范。它们是一般方案的**实例**。

#### 2.2.3.1. 通用方案
1. 通用方案提供了一个**框架**，用于生成**大量**通用的，独立于系统的，质量属性特定的方案。
2. 每种情况都可能但不一定与我们所关注的系统相关。
3. 为了使一般情况对特定系统有用，我们必须使它们**特定于系统**。
4. 使通用场景系统特定于特定环境意味着将其**转换**为特定系统的具体术语。

#### 2.2.3.2. 质量属性方案建模
![](img/lec2/5.png)

1. 刺激(Stimulus)：到达系统时需要考虑的**条件**
2. 刺激源(Source of Stimulus)：产生刺激的**实体**(人，系统或任何促动器)
3. 应对(Response)：刺激措施到来之后开展的**活动**
4. 响应措施(Response Measure)：对刺激的响应应以某种方式进行**测量**，以便可以**测试**需求。
5. 环境(Environment)：发生刺激时系统的状况，例如过载，运行等
6. 工件(Artifact)：需求适用的**整个**系统或系统的一部分。

#### 2.2.3.3. 策略
1. 风格或样式运用策略来提供预期的收益
2. 策略是影响质量属性响应**控制**的**设计决策**，例如冗余。
3. 策略的**集合**称为体系结构策略。
4. 系统设计包括一组设计决策，其中一些决策可帮助控制**质量**属性响应；其他确保系统**功能**的实现。
5. 像模式一样，策略也可以由其他策略组成，例如，冗余可以由数据的冗余，计算的冗余组成。设计人员根据需求选择一个或另一个。
6. 策略可以用作策略等级。

![](img/lec2/6.png)

#### 2.2.3.4. 质量设计决策
1. 架构是设计决策的集合。
2. 七类设计决策(可能重叠)
   1. 职责分配
   2. 协调模型
   3. 资料模型
   4. 资源管理
   5. 架构元素之间的映射
   6. 约束时间决定
   7. 技术选择

#### 2.2.3.5. 特性
![](img/lec2/7.png)

## 2.3. 约束
1. 约束是具有**零自由度**的设计决策。
2. 约束是已经做出的**预先**指定的设计决策。
3. 通过**接受**设计决策并将其与其他受影响的设计决策进行**协调**，可以满足约束条件。

# 3. 质量属性和策略

## 3.1. 可用性
1. 应用程序的**关键**要求
2. 以**所需**的可用**时间**比例来衡量，例如
   1. 营业时间内100％可用
   2. 每周计划的停机时间不超过2个小时-24x7x52(100％可用性)
3. 与应用程序的**可靠性**有关不可靠的应用程序的可用性较差
4. 可用性损失的时间由以下因素决定：
   1. **发现**故障的时间
   2. **纠正**故障的时间
   3. **重启**应用的时间
5. 高可用性策略
   1. 消除单点故障
   2. 复制和故障转移
   3. 自动检测并重启
6. 可恢复性(例如数据库)在应用程序或系统出现故障后，可以重新建立**性能级别**并**恢复**受影响的数据的功能。
7. 可将可用性计算为在指定的时间间隔内它将在要求的范围内提供指定服务的概率。
   1. MTBF(平均无故障时间)
   2. MTTR(平均维修时间)

$$
\frac{MTBF}{MTBF + MTTR}
$$

8. 计算可用性时，可能不考虑计划内的停机时间。

## 3.2. Outage, Failure, Fault, Error
1. 可用性是指通过**减少**故障来最大程度地减少服务**中断**时间。
2. **Failure**的原因称为**Fault**。
3. 当系统无法交付该系统期望的服务时，将发生Failure。
4. Failure是系统状态的**可观察**特征。
5. 系统任何部分中的Fault都有可能导致Failure。系统可以从Failure中修复或恢复。
6. Fault发生与Failure之间的**中间状态**称为Error。

## 3.3. 服务水平协议
![](img/lec2/8.png)

1. Amazon EC2的SLA
2. AWS将通过商业上合理的努力来使Amazon EC2在服务年度内的年度正常运行率至少达到99.95％。如果Amazon EC2不符合年度正常运行时间百分比承诺，您将有资格获得服务信用。

## 3.4. 对于Failure的计划
1. 危害分析：
   1. 灾难性的
   2. 危险
   3. 重大的
   4. 未成年人
   5. 没有效果
2. 故障树分析：

![](img/lec2/9.png)

1. 故障模式，影响和严重性分析（Failure Mode, Effects, and Criticality Analysis：FMECA）
   1. FMECA依靠过去类似系统的故障历史。

![](img/lec2/10.png)

## 3.5. 可用性

### 3.5.1. 可用性通用方案
![](img/lec2/11.png)

### 3.5.2. 可用性样本方案
![](img/lec2/12.png)

### 3.5.3. 可用性策略
![](img/lec2/13.png)

### 3.5.4. Fault

#### 3.5.4.1. Fault探测
1. Ping/Echo。
   1. 一个组件发出ping命令，并期望在预定时间内在另一个组件上产生回波。
   2. Ping/Echo可以在负责一项任务的一组组件中使用。
2. 心跳（死人时间）Heartbeat(dead man time)
   1. 一个组件定期发出心跳消息（也可以携带数据），而另一个组件侦听该消息。
   2. 如果心跳失败，则假定始发组件已失败，并通知故障纠正组件。
3. 例外
   1. 识别故障的一种方法是遇到异常。
   2. 异常处理程序通常在引入异常的同一过程中执行。
4. ping和心跳策略在不同的进程中运行，异常策略在单个进程中运行。

#### 3.5.4.2. Fault恢复
1. 表决
   1. 在冗余处理器上运行的进程每个都接受等效输入并计算一个简单值，该值将发送给投票者。
   2. 如果投票者从单个过程中检测到异常行为，则它会使失败。
2. 主动冗余
   1. 所有冗余组件均以并行方式响应事件-所有组件均处于相同状态。
   2. 仅使用了一个组件的响应，其余组件则被丢弃。
   3. 发生故障时，通常不存在停机时间，因为备份是最新的，唯一的切换时间是恢复时间。
3. 被动冗余
   1. 一个组件（主要）响应事件，并通知其他组件（辅助）它们必须进行的状态更新。
   2. 发生故障时，系统必须首先确保备份状态足够新，然后才能恢复服务。
4. 备件：备用备用计算平台配置为替换许多不同的故障组件。
5. 影子操作：先前发生故障的组件可能会在“影子模式”下运行一小段时间，以确保它可以模仿工作组件的行为，然后再将其恢复正常工作。
6. 状态重新同步：被动和主动冗余策略要求要恢复的组件在恢复服务之前对其状态进行升级。
7. 检查点/回滚：检查点记录的是定期或响应特定事件创建的一致状态。
8. 从服务中删除：该策略将系统的某个组件从运行中移除，以进行一些活动以防止预期的故障。
9. 交易：事务是几个连续步骤的捆绑，这样就可以一次撤消整个捆绑。
10. 过程监控器：一旦检测到流程中的故障，监视流程就可以检测到不良流程并为其创建新实例，并按照备用策略将其初始化为适当的状态。

### 3.5.5. 可用性设计和分析的检查列表
| ![](img/lec2/14.png) | ![](img/lec2/15.png) |
| -------------------- | -------------------- |

## 3.6. 互操作性
1. 互操作性是指两个或多个系统可以在特定上下文中**通过接口**完全**改变**有意义的信息的程度
   1. **交换**数据的能力（**语法**互操作性）
   2. 能够正确**解释**数据（**语义**互操作性）
2. 互操作性需要确定与**谁，什么以及在什么情况**下（上下文）。
3. 互动：夏琳说金告诉她特雷弗听说希瑟想参加你的聚会。
4. 互操作性的两个重要方面：
   1. **发现**：服务的使用者必须发现服务的**位置，身份和接口**。
   2. **处理回应**：
      1. 向请求者**报告**并做出**响应**。
      2. 将其响应**发送**到另一个系统。
      3. 向任何感兴趣的各方**广播**其回复。

### 3.6.1. 互操作性的通用方案
![](img/lec2/16.png)

### 3.6.2. 互操作性的样本方案
![](img/lec2/17.png)

### 3.6.3. 互操作性的策略
![](img/lec2/18.png)

1. 定位：**发现**服务：通过搜索已知目录服务来找到服务，多级间接。
2. 管理界面：
   1. **编排**：使用控制机制来协调，管理和排序特定服务的调用。
   2. **定制界面**：添加或删除界面功能。

### 3.6.4. 互操作性的检查列表
| ![](img/lec2/19.png) | ![](img/lec2/20.png) |
| -------------------- | -------------------- |

## 3.7. 可修改性
1. 可修改性涉及**更改**以及进行更改所**花费的时间或金钱**，包括这种可更改性影响其他功能或质量属性的程度。
2. 为变更做**准备**是有代价的，而**进行**变更则要付出代价。
3. 计划可修改性的四个问题
   1. 有什么可以改变的？
   2. 变化的**可能性**是多少？
   3. **何时**进行更改，谁进行更改？
   4. 变更的**费用**是多少？
4. 如果更改少于预期，则可能不需要昂贵的修改机制。
5. N * 不使用机械装置进行更改的成本 $\leq$ 安装机械装置的成本 +（N *使用机械装置进行更改的成本）。

### 3.7.1. 可修改性的通用方案
![](img/lec2/21.png)

### 3.7.2. 可修改性的样本方案
![](img/lec2/22.png)

### 3.7.3. 可修改性的策略
![](img/lec2/23.png)

1. **拆分模块**：如果要修改的模块包含**大量功能**，则修改成本可能会很高。
2. **增加语义一致性**：如果模块中的职责A和B不能达到**相同的目的**，则应通过创建新模块或将职责移至现有模块将它们放置在不同的模块中。
3. **封装**为模块引入了显式**接口**，并减少了对一个模块的更改**传播**到其他模块的可能性。
4. 使用**中介**打破**依赖**。
5. 当两个模块受到相同更改的影响时，请进行**重构**。
6. **延迟绑定**：在生命周期中与初始定义阶段**不同的阶段**绑定某些参数的值。

| ![](img/lec2/24.png) | ![](img/lec2/25.png) |
| -------------------- | -------------------- |

## 3.8. 性能
1. 性能与**时间**有关，软件与系统满足时序要求的能力有关。
2. 所有系统都有性能要求，即使未明确表示也是如此。
3. 响应时间的两个基本因素：
   1. 处理时间（系统**正在**响应时）
   2. 阻塞时间（系统**无法**响应时）

### 3.8.1. 性能的通用方案
![](img/lec2/26.png)

### 3.8.2. 性能的样本方案
![](img/lec2/27.png)

### 3.8.3. 性能的策略
![](img/lec2/28.png)

1. 在**需求**方面
   1. 管理**采样率**（降低采样频率）
   2. 限制事件响应：当离散事件到达系统的速度太快而无法处理时，必须将事件**排队**，直到可以处理它们为止。
   3. 如果不是所有事件都同样重要，则对事件进行**优先级**排序。
   4. 通过使用**中介**来增加处理事件流的资源，从而减少开销
2. 在**资源**方面
   1. 增加**资源**（更快的处理器，更多的内存，更快的网络...）
   2. 如果可以**并行**处理请求，请引入并发性。
   3. 维护多个计算副本：使用负载平衡器将新工作分配给可用的**重复**服务器之一。
   4. 维护数据的多个副本：
      1. 快取
      2. 资料复制

| ![](img/lec2/29.png) | ![](img/lec2/30.png) |
| -------------------- | -------------------- |

## 3.9. 安全性
1. 安全性衡量系统**保护**数据和信息免遭**未授权访问**的能力，同时仍提供对授权人员和系统的访问权限。
2. 安全性的三个特征：（CIA）
   1. 机密性，Confidentiality：防止**未经授权**访问数据和服务。
   2. 完整性，Integrity：数据和服务不会受到**未经授权**的操纵。
   3. 可用性，Availability：系统将可供**合法使用**。

### 3.9.1. 安全性的通用方案
![](img/lec2/31.png)

### 3.9.2. 安全性的样本方案
![](img/lec2/32.png)

### 3.9.3. 安全性的策略
![](img/lec2/33.png)

1. 通过将系统内的网络流量或服务请求模式与一组签名或已知模式进行比较来检测**入侵**
2. 检测服务**拒绝**
3. 使用校验和或哈希值验证**消息的完整性**。
4. 确定参与者-系统的任何**外部**输入的**来源**。
5. **验证**演员或他们所要扮演的角色。
6. **授权**有权访问和修改数据或服务的行为者。
7. **限制**对计算资源的**访问**。
8. 通过最小化系统的攻击面来**限制暴露**。
9. **加密**数据。
10. 正在进行攻击时，撤消对**敏感资源**的访问。

### 3.9.4. 安全性的检查列表
| ![](img/lec2/34.png) | ![](img/lec2/35.png) |
| -------------------- | -------------------- |

## 3.10. 可测试性
1. 可测试性是指可以使软件通过（通常基于执行）测试来证明其故障的难易程度。
2. 为了使系统能够正确测试，必须有可能控制每个分量S的输入，然后观察其输出。

![](img/lec2/36.png)

### 3.10.1. 可测试性的通用方案
![](img/lec2/37.png)

### 3.10.2. 可测试性的样本方案
![](img/lec2/38.png)

### 3.10.3. 可测试性的策略
![](img/lec2/39.png)

1. **控制和观察系统状态**：维护某种状态信息，允许测试人员为该状态信息分配一个值，和/或使测试人员可以按需访问该信息。
   1. **专用界面**使您可以控制或捕获组件的值
   2. **记录/回放**导致故障的状态，然后重新创建故障。
   3. **沙盒**将系统的实例与现实世界隔离开来，可以进行实验以消除其后果。
2. **限制复杂度**：复杂的软件更难测试，因为它的操作状态空间很大，并且在大状态空间中重新创建精确状态更加困难。
   1. 限制结构的**复杂性**，避免、减少或解决组件之间的**依赖**关系；隔离和封装对外部环境的依赖关系。
      1. 限制派生一个类的**类的数量**。
      2. 限制继承**树的深度**和类的子级数。
      3. 限制**多态**和**动态调用**。
   2. 限制**不确定性**-限制**行为复杂性**：非确定性系统更难测试。

### 3.10.4. 可测试性的检查列表
| ![](img/lec2/40.png) | ![](img/lec2/41.png) |
| -------------------- | -------------------- |

## 3.11. 易用性
1. 可用性与用户完成所需任务的**难易程度**以及系统提供的用户**支持**的类型有关。
2. 可用性包括以下几个方面：
   1. **学习**系统功能
   2. **有效**使用系统
   3. 最小化**错误的影响**
   4. 使系统**适应**用户需求
   5. 增强信心和**满意度**

### 3.11.1. 易用性的通用方案
![](img/lec2/42.png)

### 3.11.2. 易用性的样本方案
![](img/lec2/43.png)

### 3.11.3. 易用性的策略
![](img/lec2/44.png)

1. 支持用户主动权：支持用户纠正错误或提高效率。
   1. **取消**
   2. **撤消**：系统必须维持足够数量的系统状态，以便可以恢复更早的状态。
   3. 用户启动长时间操作运行时**暂停/恢复**
   4. 将较低级别的对象**聚合**到一个**组**中，以便可以将操作应用于该组。
2. **初步支持**系统：确定系统用来预测其自身行为或用户意图的模型。
   1. 维护**任务模型**：确定**上下文**，以便系统可以了解用户的尝试并提供帮助。
   2. 维护**用户模型**：代表用户的关于**系统的知识**。
   3. 维护**系统模型**：确定预期的**系统行为**，以便可以向用户提供适当的反馈。

| ![](img/lec2/45.png) | ![](img/lec2/46.png) |
| -------------------- | -------------------- |

## 3.12. 更多的能力
![](img/lec2/47.png)

# 4. 在架构上重要的要求
1. 体系结构上的重要要求（ASR）是对体系结构产生**深远影响**的要求-如果没有这样的要求，体系结构可能会发生**巨大的变化**。
2. QA要求越**困难和重要**，就越有可能显着影响体系结构，从而成为ASR。
3. 如何系统地识别将影响架构的ASR和其他因素？
   1. 从**需求**文档中收集ASR
   2. 通过采访**利益相关者**来收集ASR
   3. 通过了解**业务目标**来收集ASR
   4. 在**实用程序树**中管理ASR

## 4.1. 从需求文档中收集ASR
1. 无论是使用"MoSCoW"样式指定需求还是作为"用户故事"的集合来指定需求，这些都不能帮助您确定质量属性。
2. 需求文档通常会以两种方式使架构师**失败**：
   1. 需求规范中的大多数内容都不会影响体系结构。
      1. 系统应模块化
      2. 系统应显示出高可用性
      3. 系统应满足用户的性能期望
   2. 对架构师有用的大部分内容甚至都没有出现在最佳需求文档中:在收购环境中，需求文档代表的是收购方的利益，而不是开发商的利益。
3. 如果某项要求影响了**关键体系结构设计决策**的制定，那么根据定义，它就是ASR。

## 4.2. 通过和涉众面谈来收集ASR
1. 品质细化工作坊（QAW）
   1. QAW演示和介绍
   2. 业务任务介绍
   3. 建筑计划介绍
   4. 架构驱动程序的识别：就精简的架构驱动程序列表达成共识，其中包括总体需求，业务驱动程序，约束和质量属性。
   5. 场景集思广益：每个利益相关者都表达一个场景，表示他/她对系统的关注。
   6. 方案合并（合并类似方案）
   7. 方案优先级（通过投票）
   8. 方案细化：对最重要的方案进行细化和阐述。
2. QAW的结果包括架构驱动程序列表和利益相关者（作为一个小组优先考虑）的一组（2A方案）。

## 4.3. 通过Utility树来获取ASR
![](img/lec2/48.png)

## 4.4. 基于决策来发现ASR的方法

### 4.4.1. 结合ASR工作
1. 在实践中，通常不会引发ASR（尤其是NFR），也没有明确规定。
   1. 许多软件需求规范根本不包含NFR。
   2. 同样，许多敏捷项目都没有包含与ASR相关的用户案例。
2. 有没有更好的办法？
3. 在我们的TraceLab项目中，我们采用了角色驱动的方法，使我们能够在项目早期发现具有架构重要性的需求，并利用我们的知识对架构设计和实施做出明智的决策。

### 4.4.2. TraceLab中的ASR
1. TraceLab是一项由国家科学基金会资助的200万美元的项目
2. 由DePaul大学，威廉和玛丽学院，肯特州立大学和大学的合作者开发。 肯塔基州。
3. 旨在通过促进创新和创造力，增强可追溯性研究人员之间的协作，降低新可追溯性研究项目的启动成本和工作量以及促进技术转让来授权未来的可追溯性研究。
4. 提供了一个环境，研究人员可以在此环境中设计和执行实验，共享组件和数据集，并在受控的环境中比较评估结果。

### 4.4.3. 考虑折中
![](img/lec2/49.png)

### 4.4.4. 传统的HCI角色
1. 我们决定通过开发一组精通架构的角色来表示冲突的需求。
2. 传统上，角色构建涉及对用户进行调查，对其进行分类，制定使用假设，进行验证，创建方案以及最终设计角色。
3. 我们的项目太耗时，即过多的前期工作会阻碍我们实现目标。
4. 解决方案：角色草图。

### 4.4.5. 精通架构的角色（精简版）
![](img/lec2/50.png)

### 4.4.6. 几个例子
| ![](img/lec2/51.png) | ![](img/lec2/52.png) |
| -------------------- | -------------------- |
| ![](img/lec2/53.png) | ![](img/lec2/54.png) |
| ![](img/lec2/55.png) | ![](img/lec2/56.png) |
| ![](img/lec2/57.png) | ![](img/lec2/58.png) |
| ![](img/lec2/59.png) |                      |
